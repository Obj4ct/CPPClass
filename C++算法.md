# 算法

## 1. 模拟法

### 1.1 什么是模拟法

模拟法，顾名思义，是一种通过**模拟真实系统或过程**来研究其行为和性能的方法。

它不直接对系统进行数学分析，而是尝试**重现系统随时间演变的过程**，从而观察和收集数据，进而推断系统的特性。

**核心思想**

模拟法的核心是建立一个模型，这个模型能够模仿或表示真实世界系统中的关键元素、关系和动态行为。然后，通过运行这个模型，观察其在不同条件下的响应，从而获得对真实系统的理解。

### 1.2 模拟法的主要特点

**主要特点：**

1. **动态性：** 模拟法通常关注系统随时间变化的动态行为，而非仅仅静态的属性。
2. **实验性：** 它类似于在计算机上进行实验。通过改变模型中的参数或输入条件，可以观察系统行为的变化。
3. **复杂系统适用性：** 对于那些过于复杂，难以用解析（数学公式）方法求解的系统，模拟法是特别有用的工具。
4. **预测性：** 模拟可以用来预测系统在未来或不同操作条件下的表现。
5. **试错成本低：** 在计算机模型上进行模拟，比在真实系统中进行实验的成本要低得多，风险也小得多。

**例如**

飞行器的运动轨迹模拟、流体力学模拟、电力系统负荷变化模拟

### 1.3 模拟的基本流程

**定义问题：** 明确要解决的问题和模拟的目标。

**系统分析：** 识别系统边界、关键组件、变量和它们之间的关系。

**模型建立：** 将系统逻辑转化为计算机模型，包括：

- 确定系统状态变量。
- 定义事件和事件发生条件。
- 指定随机变量的概率分布。
- 制定时间推进机制。

**数据收集与输入：** 收集系统运行所需的历史数据、参数和随机数。

**模型验证与确认：** 确保模型能够准确反映真实系统，并能够解决最初定义的问题。

- **验证 (Verification)：** 检查模型是否按照设计意图正确实现（模型是否正确）。
- **确认 (Validation)：** 检查模型输出是否与真实系统行为一致（模型是否有效）。

**实验设计：** 确定需要运行的模拟次数、每次模拟的长度以及要改变的参数。

**模拟运行：** 执行计算机程序，收集模拟数据。

**结果分析与解释：** 对模拟输出数据进行统计分析，提取有意义的结论，并据此做出决策。

### 1.4 模拟法的适用场景

系统过于复杂，无法进行解析分析。

在真实系统上进行实验成本过高或风险太大。

需要预测系统在不同条件下的未来表现。

用于系统设计和优化，评估不同方案的效果。

研究系统对随机输入或扰动的响应。

### 1.5 例子

*这是一口很深的井（相对于青蛙而言），井壁由m块圆环形的砖头构成，每块砖头的高度都是p，青蛙每天白天最多能够向上爬的高度是q。* 

 *但是，很不幸的是，晚上砖头会渗水，会变得很滑，如果青蛙不能藏在两块砖头之间，那么青蛙将会滑落回井底。* 

 *还好青蛙是公主变的，还保留了公主的智商，在确定当天无法爬出井口的情况下，会选择白天结束前躲在尽可能高的砖缝之间，避免晚上跌落。* 

 *问：青蛙要花几天才能爬出来。* 

 *输入描述* 

 *一个正整数n，表示案例的数量。* 

 *每组案例由三个正整数m、p、q组成。(m<=5000, p<=1000, q<=1000)* 

 *输出描述* 

 *针对每组案例，输出一个整数，表示爬出来需要的天数。如果无法爬出来，则输出-1。* 

 *样例输入* 

 *2* 

 *5 2 3* 

 *5 3 2* 

 *样例输出* 

 *5* 

 *-1*

```cpp
#include <iostream>

int main() 
{
    int n; // 案例数量
    std::cin >> n;

    while (n--)
    {
        long long m, p, q; // 使用 long long 防止 m*p 溢出
        std::cin >> m >> p >> q;

        long long total_depth = m * p; // 井的总深度
        long long current_height = 0;  // 青蛙当前高度
        int days = 0;                  // 天数

        // 特殊情况：如果青蛙每天爬的高度 q 小于一块砖的高度 p，
        if (q < p ) 
        { 
            std::cout << -1 << std::endl;
            continue; // 处理下一个案例
        }
        
        // 另一种特殊情况：如果井深为0，或者q本身就能一步出井（即使q<p，但如果井就那么深）
        // 比如 m=1, p=10, q=5。total_depth=10。q<p但是青蛙只需要爬10就可以出井，5+5...
        // 应该考虑的是青蛙是否能一次性爬到total_depth。
        // 如果 q >= total_depth，青蛙第一天就能出去，除非total_depth是0 (m=0)
        if (total_depth == 0) // 井是空的，0天
        { 
             std::cout << 0 << std::endl;
             continue;
        }

        while (true)
        {
            days++; // 天数增加

            // 白天爬升
            current_height += q;

            // 判断是否出井
            if (current_height >= total_depth) 
            {
                std::cout << days << std::endl;
                break; // 青蛙已爬出
            }

            // 晚上处理：如果未出井，躲到尽可能高的砖缝
            // 由于青蛙会滑回井底的条件是“不能藏在两块砖头之间”，
            // 且它会“选择白天结束前躲在尽可能高的砖缝之间”，
            // 这意味着青蛙能安全过夜的高度必须是 p 的整数倍。
            // 并且，如果它爬不到第一块砖头的高度 p，它就会掉回井底。
            // 所以，如果 current_height < p，它当晚就会回到0。
            // 如果 current_height >= p，它会停留在 (current_height / p) * p 的位置。
            if (current_height < p) 
            {
                 // 如果白天爬了 q，但是连一块砖的高度都够不上，
                 // 且之前不是在井口，那么它当天晚上会滑回井底。
                 // 这种情况意味着永远无法爬出。
                 // 这个条件已经在循环前 if (q < p && m > 0) 覆盖了
                 // 理论上如果 q >= p，则 current_height 至少会是 p
                 // 所以这里可以不用特别处理 current_height = 0 的情况
                 std::cout << -1 << std::endl; // 此时意味着无法爬上第一块砖，永远出不来
                 break;
            } 
            else 
            {
                current_height = (current_height / p) * p; // 青蛙停留在能过夜的最高砖缝
            }
             
            // 检查是否陷入无限循环（例如，每次爬升后，晚上都会滑回同样的高度，无法进步）
            // 如果 current_height 在某次迭代结束后没有增长，并且还没出井，则陷入死循环
            // 考虑到如果 q < p，已经在前面处理了 -1 的情况
            // 如果 q >= p，那么每次 current_height 至少能增加 q - (q % p)
            // 每次循环至少有 progress >= p
            // 实际上，如果青蛙能爬过一块砖的高度，它就总能进步
            // 所以陷入死循环的唯一情况是 q < p，这已经在前面处理。
            // 这里不需要额外的死循环判断
        }
    }

    return 0;
}
```

通过程序一步步地重现了青蛙每天爬井的整个过程，直到达到最终条件（爬出井口或确定无法爬出）



## 2.二分查找

### 2.1 什么是二分查找

二分查找（Binary Search）又叫折半查找，是一种高效的查找算法，它主要用于在**已排序的**数据集合中查找特定元素的位置。它的核心思想是每次将查找范围缩小一半。

![image-20250708154936737](C:\Users\zthen\AppData\Roaming\Typora\typora-user-images\image-20250708154936737.png)

### 2.2 二分查找前提

#### 1.已排序

要进行二分查找的数据集合**必须是已排序的**（升序或降序均可）。如果数据未排序，二分查找将无法正确工作。

例如

1 2 3 4 5 6 7

7 6 5 4 3 2 1

不能是

1 3 2 4 6 5 7 

#### 2. 必须是顺序存储结构 

顺序存储结构（Sequential Storage Structure）是计算机内存中一种基本的数据存储方式。它的核心思想是：**将数据元素存储在一组地址连续的存储单元中。**

简单来说，如果你的数据是按照顺序存储的，那么在内存中它们也是一个接一个地紧密排列着。这种存储方式使得数据元素在逻辑上的相邻关系，在物理存储上也得以体现。

**物理地址连续：** 这是顺序存储结构最显著的特征。所有数据元素在内存中是紧密相连的，形成一个连续的内存块。

**随机访问（Random Access）：** 由于元素在内存中是连续的，并且每个元素的大小通常是固定的，你可以通过一个简单的数学公式，根据元素的索引（下标）直接计算出任何一个元素的内存地址。这使得访问任何一个元素的时间复杂度都是 O(1)，也就是说，访问第一个元素和访问第一百个元素所花费的时间是相同的。

- 例如，在一个整数数组中，如果知道第一个整数的地址和每个整数占用的字节数，那么第 `i` 个整数的地址可以立即计算出来。

**存储密度高：** 除了数据本身，不需要额外的存储空间来维护元素之间的逻辑关系（比如链表需要额外的指针来指向下一个元素）。

**插入和删除效率低：** 这是顺序存储结构的主要缺点。

- 如果在中间位置插入一个新元素，为了保持所有元素的连续性，需要将该位置之后的所有元素向后移动一个位置，以腾出空间。
- 如果在中间位置删除一个元素，同样需要将该位置之后的所有元素向前移动一个位置，以填补空缺。
- 这些移动操作的时间复杂度通常是 O(n)，其中 `n` 是需要移动的元素数量。
- 但在末尾进行插入和删除操作效率较高，通常是 O(1)。

**大小通常固定或需要扩容：** 典型的顺序存储结构（如C++中的静态数组）在创建时就需要指定大小。如果需要动态调整大小，通常涉及重新分配一个更大的内存块，然后将所有旧数据复制到新内存中，这会带来额外的开销。



**典型的实现：**

- **数组 (Array)：** 这是最经典、最常用的顺序存储结构。无论是 C++ 中的基本数组 `int arr[10];`，还是标准库中的 `std::vector`（虽然它在逻辑上是动态的，但其底层实现仍然是连续的内存块），都属于顺序存储。

**总结：**

顺序存储结构因其快速的随机访问特性而非常高效，特别适合那些需要频繁通过索引来访问数据，并且数据量相对稳定，或者对插入/删除操作不那么频繁的场景。但对于需要频繁进行中间插入和删除操作的场景，其性能可能会受到限制。

### 2.3 算法思想

**确定查找范围：** 首先，算法会确定一个查找范围，通常是整个数据集合。

**比较中间元素：** 将要查找的目标值与当前查找范围的**中间元素**进行比较。

- **如果目标值等于中间元素：** 查找成功，算法返回中间元素的位置。
- **如果目标值小于中间元素：** 说明目标值可能位于中间元素的左侧，因此查找范围缩小到中间元素的左半部分。
- **如果目标值大于中间元素：** 说明目标值可能位于中间元素的右侧，因此查找范围缩小到中间元素的右半部分。

**重复过程：** 算法会在新的查找范围内重复上述步骤，直到找到目标元素，或者查找范围变为空（这表示目标元素不存在于数据集合中）。

### 2.4 算法的时间复杂度

二分查找的效率非常高。每次比较都会将查找范围缩小一半。因此，对于大小为 N 的数据集合，二分查找的**时间复杂度是 O(logN)**。这意味着即使数据量非常大，查找所需的时间也只会以对数的速度增长，非常高效。

### 2.5 流程

例如在1-100中查找56

![image-20250708155352234](C:\Users\zthen\AppData\Roaming\Typora\typora-user-images\image-20250708155352234.png)

```cpp
#include <iostream> // 用于输入输出

int main() 
{
    int target_value; // 使用局部变量来存储要查找的目标值
    std::cout << "请输入一个1到100之间的整数进行查找: ";
    std::cin >> target_value; // 读取要查找的目标值

    int low = 1;  // 查找范围的左边界（值本身）
    int high = 100; // 查找范围的右边界（值本身）
    bool found = false; // 标记是否找到

    // 当 low <= high 时，表示查找范围有效
    while (low <= high) 
    {
        int mid = low + (high - low) / 2; // 计算中间值，防止溢出

        if (mid == target_value)
        { // 找到了目标值
            std::cout << "成功找到！目标值是: " << mid << std::endl;
            found = true;
            break; // 找到后立即退出循环
        } 
        else if (mid < target_value) 
        { // 中间值比目标值小，目标在右半部分
            low = mid + 1; // 缩小左边界
        } 
        else 
        { // mid > target_value，中间值比目标值大，目标在左半部分
            high = mid - 1; // 缩小右边界
        }
    }

    if (!found) 
    { // 如果循环结束还没找到
        std::cout << "查找失败！目标值 " << target_value << " 不在 1 到 100 的范围内或未找到。" << std::endl;
    }

    return 0;
}
```



## 3.分治算法

## 4.贪心算法

## 5.动态规划

## 6.枚举法

### 1.1 什么是枚举法

**枚举法**，也称为**穷举法**或**列举法**，是一种在解决问题时，将问题所有可能的**解**或**情况**一一列举出来，然后对每一个解或情况进行判断，从而找出符合条件的解的方法。简单来说，就是“一个不漏地把所有可能性都试一遍”。

简单来说：**就是for循环一直试**

### 1.2 何时使用枚举法

枚举法虽然简单直观，但并不是适用于所有问题。它通常在以下情况中比较适用：

- **问题规模较小**：当所有可能的情况数量有限且不大时，枚举法效率较高。如果可能性太多，枚举法可能会非常耗时。
- **解空间可以明确定义**：能够清晰地确定所有可能解的范围和特征。
- **判断条件明确**：有明确的标准来判断一个解是否符合要求。
- **想不到更高效的算法**：在没有更优化、更高效的算法（如数学公式、动态规划、贪心算法等）时，枚举法可以作为一种备选方案。

### 1.3 枚举法的优缺点

优点

- 简单直观：易于理解和实现，不需要复杂的理论知识。
- 准确性高：如果枚举范围正确且判断条件无误，枚举法通常能找到所有符合条件的解，不会遗漏。

缺点

- 效率低下：当问题规模较大时，可能的组合数量会呈指数级增长，导致计算量巨大，耗时过长。
- 不适用于大规模问题：对于计算复杂度高的问题，枚举法几乎不可行。

### 1.4 例子

#### 1.4.1 例一

今有鸡兔同笼，上有三十五头，下有九十四足，问鸡兔各几何?

输入描述

无

输出描述

鸡的数量、兔的数量



输入样例 1

```cpp
无
```

输出样例 1

```cpp
23 12
```

提示

有若干只鸡和兔在同个笼子里，从上面数，有 35 个头；从下面数，有 94只脚。求笼中各有几只鸡和兔



枚举所有可能情况

```cpp
#include<iostream>
using namespace std;
int main()
{
    int i,j;
    //循环鸡可能的范围 
    for(i=1;i<=35;i++)
    {
        //循环兔可能的范围 
        for(j=1;j<=35;j++)
        { 
        if(i+j == 35 && 2*i+4*j == 94) 
            cout<<i<<" "<<j<<endl;
        } 
    }
    return 0; 
}
```

因为循环太多次了

因此需要优化：

```cpp
#include<iostream>
using namespace std;
int main()
{
    int i;
    //循环鸡可能的范围
    for(i=1;i<=35;i++)
    {
        if(i*2+(35-i)*4 == 94)
        {
            cout<<i<<" "<<35-i<<endl;
        }
    }
}
```



#### 1.4.2 例二

今有鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？

输入描述

无

输出描述

鸡翁、鸡母、鸡雏的数量



输入样例 1

```cpp
无
```

输出样例 1

```cpp
4 18 78
8 11 81
12 4 84
```

提示

公鸡 55 文钱一只，母鸡 33 文钱一只，小鸡 33 只一文钱，用 100 文钱买一百只鸡，其中公鸡，母鸡，小鸡都必须要有，问公鸡，母鸡，小鸡要买多少只刚好凑足 100 文钱

```cpp
#include<iostream>  
using namespace std;  

int main() {  
    int x, y, z;  // 定义三个整型变量x,y,z，分别表示三种物品的数量
    
    // 第一层循环：枚举第一种物品的数量x，从1到99
    for(x = 1; x < 100; x++) {
        // 第二层循环：枚举第二种物品的数量y，从1到99
        for(y = 1; y < 100; y++) {
            // 第三层循环：枚举第三种物品的数量z，从1到99
            for(z = 1; z < 100; z++) {
                // 检查是否满足以下三个条件：
                // 1. 总价格等于100：5元*x + 3元*y + (1/3)元*z = 100
                // 2. z必须是3的倍数（因为1/3元需要整数价格）
                // 3. 总数量等于100：x + y + z = 100
                if(5*x + 3*y + z/3 == 100 && z % 3 == 0 && x + y + z == 100) {
                    // 如果满足条件，输出x,y,z的值
                    cout << x << " " << y << " " << z << endl;
                }
            }
        }
    }
}
```

优化方法:**减少循环层数 + 数学约束条件**

```cpp
#include<iostream>
using namespace std;

int main() {
    int x, y, z;  // x:第一种物品数量，y:第二种，z:第三种

    // 优化1：x范围收紧（因为5x < 100 ⇒ x <20）
    for(x = 1; x < 20; x++) {
        // 优化2：y范围收紧（因为3y <100 ⇒ y <33）
        for(y = 1; y < 33; y++) {
            // 优化3：直接用公式计算z，省去第三层循环
            z = 100 - x - y;
            
            // 优化4：检查z是3的倍数且总价等于100
            if(z % 3 == 0 && 5*x + 3*y + z/3 == 100) {
                cout << x << " " << y << " " << z << endl;
            }
        }
    }
    return 0;
}
```

